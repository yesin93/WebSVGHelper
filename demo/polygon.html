<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Polygon Draw</title>

    <link href="../css/shapesJS.css" rel="stylesheet" type="text/css"/>
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.0/d3.min.js"></script>-->
    <script src="../libs/d3/d3.min.js"></script>
</head>
<body>
<button id='poly'>Poly</button>
<!--<script src="../js/drawRect.js"></script>-->

<script>
    d3.select('#poly').on('click', function(){ new Polygon(); });

    var w = 600, h = 500;
    var svgCanvas = d3.select('body').append('svg').attr("width", w).attr("height", h);

    function Polygon(){

        var polyPoints = [];
        var gContainer = svgCanvas.append('g');;
        var isDrawing = false;
        var linePoint1, linePoint2;
        var startPoint;


//        var polyDrag =  svgCanvas.call(d3.drag().on("start", initialPlod)
//                                                  .on('drag', secondaryPlod));

        var polyDraw = svgCanvas.on("mousedown", setPoints)
                                .on("mousemove", drawline)
                                .on("mouseup", decidePoly);

        //initial plod of the polygon point
        function setPoints(){

//            if(isDragging){
//                return;
//            }

            isDrawing = true;

            var plod = d3.mouse(this);
            linePoint1 = {x: plod[0], y: plod[1]};

            polyPoints.push(plod);

            //bad practice?
            if(startPoint === undefined){
                startPoint = polyPoints[0];
                console.log(startPoint);
            }


            gContainer.append("circle")
                .attr("cx", linePoint1.x)
                .attr("cy", linePoint1.y)
                .attr("r", 4)
                .classed("handle", true);

        }
        
        function drawline() {

            if(isDrawing){
                linePoint2 = d3.mouse(this);
                gContainer.select('line').remove();
                gContainer.append('line')
                    .attr("x1", linePoint1.x)
                    .attr("y1", linePoint1.y)
                    .attr("x2", linePoint2[0])
                    .attr("y2", linePoint2[1]);

            }

        }

        function decidePoly(){

            gContainer.select('line').remove();

            gContainer.select('polyline').remove();

            var polyline = gContainer.append('polyline').attr('points', polyPoints);
        }
    }

</script>

<script>

    /**
     *
     * taken from jsFiddle for reference
     *
     */


    //    var w = 600, h = 500;
    //    var svg = d3.select('body').append('svg').attr("width", w).attr("height", h);
    //
    //    d3.select('#polygon').on('click', function(){ new Polygon(); });

    //    function Polygon(){
    //        var path, pathArray = [], isClicking = false, firstClick = true, m1, m2, lastX, lastY;
    //
    //        var lineFunction = d3.svg.line()
    //            .x(function(d) { return d.x; })
    //            .y(function(d) { return d.y; })
    //            .interpolate("linear-closed");
    //
    //        var dragP = d3.behavior.drag().on('drag', dragPath),
    //            dragC = d3.behavior.drag().on('drag', dragCircle);
    //
    //        function dragPath(dataSource) {
    //            console.log('dragPath', dataSource);
    //            path.attr('fill', 'gray');
    //            var e = d3.event;
    //            pathArray.forEach(function(datum, index){
    //                datum.x += e.dx;
    //                datum.y += e.dy;
    //            });
    //
    //            updatePath();
    //            updateCircle();
    //        }
    //
    //        function dragCircle(dataSource) {
    //            console.log('dragCircle', dataSource);
    //            var e = d3.event;
    //            dataSource.x += e.dx;
    //            dataSource.y += e.dy;
    //            updateCircle();
    //            updatePath();
    //        }
    //
    //        function updatePath(){
    //            if(!path){
    //                path = svg.append('path');
    //            }
    //            path.attr('d', lineFunction(pathArray)).attr('fill', 'none');
    //        }
    //
    //        function drawCircle(){
    //            circle = svg.selectAll('circle').data(pathArray);
    //            circle.enter().append('circle').attr('r', 10);
    //            circle.attr('cx', function(d) { return d.x; })
    //                .attr('cy', function(d) { return d.y; });
    //        }
    //
    //        function updateCircle(){
    //            circle.attr('cx', function(d) { return d.x; })
    //                .attr('cy', function(d) { return d.y; });
    //        }
    //
    //        function intersects(x, y, cx, cy, r) {
    //            var dx = x-cx,
    //                dy = y-cy;
    //            return dx*dx + dy*dy <= r*r;
    //        }
    //
    //        svg.on('mousedown', mousedown);
    //        function mousedown() {
    //            m1 = d3.mouse(this);
    //            //console.log(m1, m2);
    //            for (var i = 0; i < pathArray.length - 1; i++) {
    //                var dataPt = pathArray[i];
    //                if(intersects(m2[0], m2[1], dataPt.x, dataPt.y, 10)){
    //                    console.log(i);
    //                    isClicking = false;
    //                    path.attr('fill','gray');
    //                    path.call(dragP);
    //                    d3.selectAll('circle').call(dragC);
    //                    break;
    //                }
    //            }
    //
    //            if (firstClick) {
    //                isClicking = true;
    //                console.log('if firstClick');
    //                pathArray = [{ 'x':  m1[0], 'y': m1[1] }, { 'x':  m1[0], 'y': m1[1] }];
    //                drawCircle();
    //                updatePath();
    //                firstClick = !firstClick;
    //            } else if (isClicking) {
    //                isClicking = true;
    //                console.log('else if isClicking');
    //                drawCircle();
    //                lastX = m2[0];
    //                lastY = m2[1];
    //                pathArray[pathArray.length] = { 'x': lastX, 'y': lastY };
    //            } else {
    //                console.log('else else');
    //            }
    //        }
    //
    //        svg.on('mousemove', mousemove);
    //        function mousemove() {
    //            m2 = d3.mouse(this);
    //            if (isClicking) {
    //                pathArray[pathArray.length - 1] = {'x': m2[0], 'y': m2[1]};
    //                updatePath();
    //            }
    //        }
    //    }

</script>
</body>
</html>